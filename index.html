<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>打刻管理</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Oswald:wght@200..700&display=swap" rel="stylesheet">
  <style>
    body {
      font-family: sans-serif;
      padding: 20px;
      background: #f9f9f9;
    }

    #todayDate {
      font-size: 18px;
      color: #999;
      margin-bottom: 10px;
    }

    #thankYouMessage {
      font-size: 18px;
      color: #e91e63;
      margin: 5px 0 10px;
      font-weight: bold;
    }

    #liveWorkTime {
      font-size: 50px;
      font-family: "Oswald", sans-serif;
      margin: 20px 0;
      color: #333;
      line-height: 1.1;  /* 行間を狭く設定 */
    }

    #workTimeAfterBreak {
      font-size: 16px;
      color: #999;
      margin-top: -15px;  /* 必要に応じて調整 */
      margin-bottom: 15px;
    }

    .button-container {
      display: flex;
      gap: 10px;
      margin-bottom: 10px;
    }

    .emoji-button {
      font-size: 30px;
      background: none;
      border: none;
      cursor: pointer;
      filter: grayscale(100%);
    }

    #logTable {
      margin-top: 20px;
      border-collapse: collapse;
      min-width: 300px;
    }

    #logTable td {
      color: #999;
      padding: 2px 2px; /* 間隔を調整 */
      white-space: nowrap;
      width: 80px; /* 時間の幅を固定 */
    }

    #logTable td:nth-child(2) {
      width: 200px; /* 内容の幅を固定 */
    }

    #clearBtn {
      font-size: 8px;
      padding: 2px 4px;
      margin-top: 10px;
      color: #444;
      background: #eee;
      border: 1px solid #ccc;
      border-radius: 4px;
      display: none;
      cursor: pointer;
      height: auto;
      width: auto;
    }

    #clearBtn:hover {
      background: #ddd;
    }

  /* スマホ表示のためのメディアクエリ */
  @media (max-width: 100px) {
    body {
      padding: 10px;
    }

    #liveWorkTime {
      font-size: 40px; /* スマホ用に文字サイズ調整 */
      text-align: center;
    }

    #workTimeAfterBreak {
      font-size: 14px; /* スマホ用にフォントサイズ調整 */
      text-align: center;
    }

    .button-container {
      flex-direction: column; /* ボタンを縦に並べる */
      align-items: center;
    }

    .emoji-button {
      font-size: 24px; /* ボタンのフォントサイズを少し小さくする */
      margin-bottom: 10px; /* ボタン間の隙間を調整 */
    }

  </style>
</head>
<body>

  <div id="todayDate"></div>
  <div id="thankYouMessage"></div>
  <div id="liveWorkTime">--:--:--</div>
  <div id="workTimeAfterBreak">連続稼働：</div>

  <div class="button-container">
    <button id="startPauseBtn" class="emoji-button" onclick="handleStartPause()">▶️</button>
    <button id="endBtn" class="emoji-button" onclick="endWork()" style="display: none;">⏹️</button>
  </div>

  <table id="logTable">
    <tbody id="logBody"></tbody>
  </table>

  <button id="clearBtn" onclick="clearLog()">クリア</button>

  <script>
    let log = [];
    let pauseStart = null;
    let totalBreak = 0;
    let clockInTime = null;
    let clockOutTime = null;
    let inBreak = false;
    let currentPhase = 'notStarted';
    let lastDisplayed = '';
    let totalElapsed = 0;
    let workAfterBreakStart = null;

    function formatTimeShort(date) {
      return date.toLocaleTimeString('ja-JP', { hour: '2-digit', minute: '2-digit' });
    }

    function formatLogTime(date) {
      return date.toLocaleTimeString('ja-JP', { hour: '2-digit', minute: '2-digit' });
    }

    function formatSecondsToHMS(sec) {
      const h = Math.floor(sec / 3600);
      const m = Math.floor((sec % 3600) / 60);
      return `${h > 0 ? h + '時間' : ''}${m}分`;
    }

    function formatSeconds(sec) {
      const h = String(Math.floor(sec / 3600)).padStart(2, '0');
      const m = String(Math.floor((sec % 3600) / 60)).padStart(2, '0');
      const s = String(sec % 60).padStart(2, '0');
      return `${h}:${m}:${s}`;
    }

    function addLog(message) {
      const now = new Date();
      const row = document.createElement('tr');
      row.innerHTML = `<td>${formatLogTime(now)}</td><td>${message}</td>`;
      document.getElementById('logBody').appendChild(row);  // DOM 更新のタイミングを確保
      log.push(`${formatLogTime(now)}\t${message}`);

      // ログの追加後、スクロールを一番下に移動
      const logBody = document.getElementById('logBody');
      logBody.scrollTop = logBody.scrollHeight;

      // 「クリア」ボタンの表示
      document.getElementById('clearBtn').style.display = 'inline-block';
      
      saveState();
    }

    function updateLiveTime() {
      const now = new Date();
      if (clockInTime && !clockOutTime) {
        let elapsed = Math.floor((now - clockInTime) / 1000);
        let breakNow = inBreak && pauseStart ? Math.floor((now - pauseStart) / 1000) : 0;
        const actualElapsed = elapsed - (totalBreak + breakNow);
        totalElapsed = actualElapsed;
        const displayTime = formatSeconds(actualElapsed);

        // 不要な更新を避けるため、前回と同じ表示時間なら更新しない
        if (!inBreak && displayTime !== lastDisplayed) {
          document.getElementById('liveWorkTime').textContent = displayTime;
          lastDisplayed = displayTime;
        }

        if (workAfterBreakStart) {
          const workAfterBreakElapsed = Math.floor((now - workAfterBreakStart) / 1000);
          
          // 1時間を超えた場合に赤文字で表示
          const workAfterBreakTimeText = `連続稼働：${formatSecondsToHMS(workAfterBreakElapsed)}`;
          const workAfterBreakElement = document.getElementById('workTimeAfterBreak');
          if (workAfterBreakElapsed > 3600) {
            workAfterBreakElement.style.color = 'red'; // 1時間を超えたら赤文字
          } else {
            workAfterBreakElement.style.color = '#999'; // 1時間未満は通常の色
          }
          workAfterBreakElement.textContent = workAfterBreakTimeText;
        }
      }
      requestAnimationFrame(updateLiveTime);
    }

    function handleStartPause() {
      const icon = document.getElementById('startPauseBtn');
      const endBtn = document.getElementById('endBtn');

      if (currentPhase === 'notStarted') {
        clockInTime = new Date();
        addLog('開始');
        currentPhase = 'working';
        icon.textContent = "⏸️";
        endBtn.style.display = 'inline-block';
        document.getElementById('thankYouMessage').textContent = '';
      } else if (currentPhase === 'working') {
        pauseStart = new Date();
        inBreak = true;
        currentPhase = 'paused';
        icon.textContent = "▶️";
        addLog('一時停止');
      } else if (currentPhase === 'paused') {
        const now = new Date();
        const breakSec = Math.floor((now - pauseStart) / 1000);
        totalBreak += breakSec;
        pauseStart = null;
        inBreak = false;
        currentPhase = 'working';
        icon.textContent = "⏸️";
        workAfterBreakStart = new Date();  // 再開時間を記録
        addLog(`再開（休憩: ${formatSecondsToHMS(breakSec)}）`);
      }
      saveState();
    }

    function endWork() {
      const isConfirmed = confirm("終了してよろしいですか？");
      if (!isConfirmed) {
        return; // ユーザーがキャンセルした場合は処理を中断
      }

      const icon = document.getElementById('startPauseBtn');
      clockOutTime = new Date();
      if (inBreak && pauseStart) {
        totalBreak += Math.floor((clockOutTime - pauseStart) / 1000);
        pauseStart = null;
        inBreak = false;
      }
      addLog('終了');
      const elapsed = Math.floor((clockOutTime - clockInTime) / 1000);
      const actualElapsed = elapsed - totalBreak;
      const workTimeStr = formatSecondsToHMS(actualElapsed);
      currentPhase = 'notStarted';
      icon.textContent = "▶️";
      document.getElementById('endBtn').style.display = 'none';
      document.getElementById('thankYouMessage').innerHTML = `お疲れさまでした！<br>累計労働時間：${workTimeStr}`;
      saveState();
    }

    function clearLog() {
      if (confirm("ログをすべて削除してもよろしいですか？")) {
        log = [];
        pauseStart = null;
        totalBreak = 0;
        clockInTime = null;
        clockOutTime = null;
        inBreak = false;
        currentPhase = 'notStarted';
        document.getElementById('logBody').innerHTML = '';
        document.getElementById('liveWorkTime').textContent = '--:--:--';
        document.getElementById('workTimeAfterBreak').textContent = '連続稼働：';
        document.getElementById('startPauseBtn').textContent = "▶️";
        document.getElementById('endBtn').style.display = 'none';
        document.getElementById('clearBtn').style.display = 'none';
        document.getElementById('thankYouMessage').textContent = '';
        localStorage.removeItem('dakcokuState');
      }
    }

    function updateTodayDate() {
      const now = new Date();
      const dateStr = now.toLocaleDateString('ja-JP', {
        weekday: 'short',
        year: 'numeric',
        month: 'numeric',
        day: 'numeric'
      });
      const timeStr = now.toLocaleTimeString('ja-JP', {
        hour: '2-digit',
        minute: '2-digit'
      });
      document.getElementById('todayDate').textContent = `${dateStr}　${timeStr}`;
    }

    function saveState() {
      const state = {
        clockInTime,
        clockOutTime,
        pauseStart,
        totalBreak,
        inBreak,
        currentPhase,
        log,
        totalElapsed,
        workAfterBreakStart
      };
      localStorage.setItem('dakcokuState', JSON.stringify(state));
    }

    function loadState() {
      const saved = localStorage.getItem('dakcokuState');
      if (!saved) return;
      const state = JSON.parse(saved);
      clockInTime = state.clockInTime ? new Date(state.clockInTime) : null;
      clockOutTime = state.clockOutTime ? new Date(state.clockOutTime) : null;
      pauseStart = state.pauseStart ? new Date(state.pauseStart) : null;
      totalBreak = state.totalBreak;
      inBreak = state.inBreak;
      currentPhase = state.currentPhase;
      log = state.log || [];
      totalElapsed = state.totalElapsed || 0;
      workAfterBreakStart = state.workAfterBreakStart ? new Date(state.workAfterBreakStart) : null;

      const logBody = document.getElementById('logBody');
      logBody.innerHTML = '';
      log.forEach(entry => {
        const [timeStr, message] = entry.split('\t');
        const row = document.createElement('tr');
        row.innerHTML = `<td>${timeStr}</td><td>${message}</td>`;
        logBody.appendChild(row);
      });

      if (log.length > 0) {
        document.getElementById('clearBtn').style.display = 'inline-block';
      }

      const icon = document.getElementById('startPauseBtn');
      icon.textContent = (currentPhase === 'paused') ? "▶️" :
                         (currentPhase === 'working') ? "⏸️" : "▶️";
      document.getElementById('endBtn').style.display = (currentPhase === 'notStarted') ? 'none' : 'inline-block';
      document.getElementById('liveWorkTime').textContent = formatSeconds(totalElapsed);
      if (workAfterBreakStart) {
        document.getElementById('workTimeAfterBreak').textContent = `連続稼働：`;
      }
    }

    loadState();
    updateTodayDate();
    setInterval(updateTodayDate, 60000);
    requestAnimationFrame(updateLiveTime);
  </script>
</body>
</html>
